#using queue to store ports for scanning
from queue import Queue
#using socket.connect to try connection to a specific port
import socket
#using threads to speed up the process
import threading
#using regular expressions to check the ip validity
import re
#using argument parser to input ip and ports as arguments to the program
import argparse

#a fancy banner
def banner():
    print(" _________________________________________________________________   ")
    print("|                                                                 |  ") 
    print("|  SSSSSSS  SSSSSSS  SSSSSSS  SS   SS  SS   SS  SSSSSSS  SSSSSSS  |  ")
    print("|  SS       SS       SS   SS  SSS  SS  SSS  SS  SS       SS   SS  |  ")
    print("|   SSSS    SS       SS   SS  SS S SS  SS S SS  S S S    SSSSSSS  |  ")
    print("|     SSS   SS       SSSSSSS  SS  SSS  SS  SSS  S S S    SSSS     |  ")
    print("|       SS  SS       SS   SS  SS   SS  SS   SS  SS       SSS SS   |  ")   
    print("|  SSSSSSS  SSSSSSS  SS   SS  SS    S  SS    S  SSSSSSS  SS   SS  |  ")
    print("|_________________________________________________________________|  ")

#trying to connect to a port on an ip address
#return true and close the connection is succed
#otherwise return false
def portscan(port):

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((args.target, port))
        sock.close()
        return True
    except:
        return False

#worker is the new sub-process
def worker():

    while not queue.empty():
        port = queue.get()
        if portscan(port):
            #print("Port ",port,"\033[1;32m is open\033[0m")
            open_ports.append(port)
        else:
            #print("Port ",port,"\033[1;31m is closed\033[0m")
            pass

#assigning a thread to the worker
def run_scanner(threads):

    thread_list = []
    for t in range(threads):
        thread = threading.Thread(target=worker)
        thread_list.append(thread)

    for thread in thread_list:
        thread.start()

    for thread in thread_list:
        thread.join()

#the argument parser
parser = argparse.ArgumentParser(description="Port Scanner")
parser.add_argument("target", type=str, metavar="<ipv4>target", help="The targeted ipv4 address")
parser.add_argument("min_port", type=int, metavar="<int>min_port", help="The lower limit of ports to scan")
parser.add_argument("max_port", type=int, metavar="<int>max_port", help="The upper limit of ports to scan")
args=parser.parse_args()

# regular expression for ipv4
ipv4_pattern = re.compile("^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$")
# check for ip validity
if not (ipv4_pattern.search(args.target)):
    print("Wrong input!")
    print("Run: ",__file__," -h to read the usage!")
    exit()
# check for ports validity
if(args.min_port<1 or args.max_port< args.min_port or args.max_port >65535):
    print("Wrong input!")
    print("Ports are in range of 1 - 65535")
    exit()

# here it starts
if(__name__=="__main__"):
    # declaration of queue and empty list of open ports
    queue = Queue()
    open_ports = []
    # assigne the number of threads
    THREADS = 16
    # fill the queue with the ports to scan
    for port in range(args.min_port, args.max_port+1):
        queue.put(port)
    # start the scanner with # threads
    run_scanner(THREADS)
    
    banner()
    if(not open_ports):
        print("\nAll ports scanned are closed")
    else:
        print("\nOpen ports: \033[1;32m",open_ports,"\033[0m")    
